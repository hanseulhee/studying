# 컴퓨터 네트워크

### 프로토콜

프로토콜이란 통신을 주도하는 **규칙들의 집합**이다.

통신하기 위해서는 반드시 개체들이 프로토콜에 합의해야 한다.

프로토콜은 무엇을, 어떻게, 언제 통신할 것인지를 규정한다.

구문(무엇을), 의미(어떻게), 타이밍(언제) 로 구성되어 있다.

### 표준

정보 통신 표준은 **사실 표준과 법률 표준**으로 구분된다.

법률 표준은 공식적인 권위를 인정받은 단체 혹은 기관에서 제정된 표준, 모두가 동의해야 함

사실 표준은 승인되지는 않았지만 일반에 널리 사용되는 표준을 의미한다.

사실표준은 **특허, 비특허**로 나뉜다.

특허 표준은 원래 자기 제품의 기본 원리를 영리 기관이 창안한 것이다. (=폐쇄 표준: 다른 회사의 제품과 호환이 되지 않기 때문) -> 법적으로 보호됌. 해당 특허 표준을 쓰면 남들은 특허비를 냄

비특허 표준은 원래 집단이나 위원회에서 개발하여 공개 영역에 공개한 표준이다. (=개방 표준: 서로 다른 시스템과의 통신을 개방하기 때문)

사실 표준이 시간이 지나 법률 표준으로 갈 수 있음

### 표준화 기구

**국제 표준화 기구 (ISO)**

OSI (개방 시스템 상호 연경) 모델

**ITU-T**

V 시리즈, X 시리즈 (전화선을 통해 데이터 통신)

**ANSI**

아스키코드 표준, 미국 표준을 제정하는 기관

**IEEE**

LAN (근거리 통신망)

**EIA**

RS-232-C

**NIST**

보안관련 (데이터 암호 표준)

**포럼 (Forum)**

특정 기술 분야에만 전념
광대역 포럼 -> DSL 포럼, ATM 포럼

**W3C**

웹 표준

**KISC (한국 산업 표준원)**

관련된 제품 인증 업무

**KATS(국가 기술 표준원)**

**TTA(한국 정보통신 기술협회)**

**OSIA(개방형 컴퓨터 연구회)**

**한국전자통신연구원 표준연구센터**

### 회선

회선이란 둘 이상의 통신 장치가 하나의 링크에 연결되는 방식

회선 구성 방식은 3가지로 구성되어 있다.

- 점대점

- 다중점

- 교환

**점대점**

1대1, 두 장치만 사용하는 단일 전용 링크

**다중점**

세 개 이상의 장치

전용이 아닌 공유 (ex 버스)

채널 용량을 시간적 또는 공간적으로 공유 (충돌 막는 법) -> 시간적으로 나눠씀 (ex 강의실), 공간적으로 나눠씀 (ex 3501, 3502)

**교환 (스위칭)**

교환기

### 접속형태 (Topology)

- 대등 대 대등 (peer to peer) : 동등하게 링크를 공유 but 충돌 가능성 높음

- 주국 종국 (primary secondary) : 통제하에 통신이 이루어짐

**그물형 (mesh)**

하나의 디바이스는 나머지 디바이스와 다 연결 가능

점대점 전용 링크

n개의 장치를 연결하려면 n(n-1)/2개의 채널이 필요함

단점.

케이블링과 포트 수가 많이 필요, 다 연결되기 때문에 설치와 재구성이 어려움, 비교적 고가임

**성형 (star)**

중간에 허브라는 중앙 제어기가 존재함. 주종관계 성립

허브하고 점대점 링크

허브로 가는 선 한가닥만 있으면 됌

허브가 교환기 역할을 담당함

mesh에 비해 비용이 적게들고 재구성이 쉽고 안정성 굿굿 but 허브가 고장나면 전체가 마비된다.

**트리형 (tree)**

능동적인 허브 active(repeater가 있음), 수동적인 허브 passive(repeater가 없음)로 나뉨

**버스형**

유도선을 이용해 붙이는 방식

제일 끝에 있는 사람은 신호가 작아짐. 그래서 선의 제한이 생김 (무한 x, 충돌 가능성 높음)

근거리 LAN 만들 때 해당 유형 잘 씀

**링형**

**혼합형 (하이브리드)**

다 혼합해서 씀

### 전송 방식

단방향 (일반통행 ex 컴퓨터&키보드), 반이중 (ex 무전기, 묻고답하고), 전이중 (양방향, ex 2차선도로)

전이중으로 갈수록 값은 비싸짐.

### 네트워크 분류

LAN (근거리 통신망), MAN (도시), WAN (국가, 전세계), PAN(개인), BAN(신체)

### 네트워크 간 연결 (Internetworks)

대표적인 것이 router

internet: 개별 네트워크를 상호 연결한 네트워크 총칭

Internet: 전세계적으로 널리 사용되고 있는 **TCP/IP**를
사용하고 있는 특정 네트워크

> 1장 개요 끝

2장

### OSI (Open System Interconnection)

ISO가 만든 OSI 모델로 개방 시스템 상호연결하는 역할을 함

서로 다른 시스템 간에 개방 통신을 위한 것

### OSI 모델 7계층

제1계층: 물리 - 정보가 상대방에게 갈 수 있게 하는 그런 모든 것 (무조건 필요함)

제2계층: 데이터 링크 - 에러를 처리해주는 기능 (에러 복원)

제3계층: 네트워크 - IP 프로토콜이 있던 것

제4계층: 전송

제5계층: 세션

제6계층: 표현 - 압축, 보안 등

제7계층: 응용 - 사용자가 직접 쓰는 것 (web 등)

관련된 계층만 바뀌게 됌. (ex 1단계가 바뀐다? 다 안바꾸고 1단계만 바뀜)

중간에 있는 네트워크 장비들은 굳이 모든 걸 알 필요 없음. 3번째까지만 통신기능 있음

**peer-to-peer(대등-대-대등)** 프로세스

해당 계층에서 통신하는 각 시스템의 프로세스 (동급, 대동한 애끼리 얘기하는 거)

**계층간 인터페이스**

계층과 계층 사이에는 인터페이스가 존재함

아래쪽은 위쪽한테 기능을 제공함, 위쪽은 아래의 서비스를 이용함

위쪽은 인터페이스가 바뀌는 것 이외에는 관심없음

즉 하나의 계층은 자기 밑에 있는 애(서비스 사용함), 자기 위에 있는 애(서비스 제공해야됌), peer to peer (건너편 동일한 애) 이 3가지의 일을 함

계층 1, 2, 3 - 네트워크 지원 계층

계층 5, 6, 7 - 사용자 지원 계층

계층 4 - 전송 계층

H2에 오면 꼬리가 붙임. 2단계가 구조가 좀 다름 (이질적인 요소 등이 포함)
2단계는 데이터가 깨진 걸 복원하는 역할을 해야하기에 정보가 많아짐 (H2에 추가비트 즉 비용을 좀 지불함)
그 다음 1단계에 주면 1010101 식으로 됌.

1단계 그다음 나가는 것은 데이터가 아닌 전송 매체임 그다음 시스템에게 전달할 시 다시 데이터로 바꿈
안깨졌는 지 확인하고 깨졌으면 이전 시스템에게 다시 줌 (이를 반복하고 성공 시 제대로 전달)

**송신쪽에서는 헤더가 늘어가면서 내려가고 수신쪽에서는 헤더가 줄어들면서 올라감**

ex

H4가 H3을 볼 수 있으면 일이 더 빨리질 수 있음 (무슨 일이 일어나는 지 아니깐) but H4는 수신쪽 애랑 약속한 것임. 그래서 H4가 바뀌면 H3도 바뀌어야 함. 이에 독립적이지 못하기에 **절대 보면 안됌**. 그 순간에는 편할 지 몰라도 굉장히 안좋게 됌.

### 계층별 기능

**물리층**

물리적인 매체를 통해 비트 흐름을 전송하기 위해 요구되는 기능을 제어하는 곳

**기계적, 전기적 특성을 여기서 다 다룸** (ex 케이블의 두께 등)

데이터 링크층으로부터 데이터를 받아 **전송될 수 있는 형태로 변환**

비트 스트림을 **전자기 신호로 변환**

신호 전송이 잘되고 있는 지 관리 감독함 (연달아 1이 계속오네 ? 문제가 있네 하고 처치를 진행함)

물리적으로 다 연결되어야 하니 이를 고려해야함

**데이터 링크층**

깨진 데이터를 복원하여 오류 없는 데이터 전달에 대한 책임을 가지는 곳 (reliable transfer)

세번째 계층으로부터 데이터를 받아서 주소와 제어벙보를 포함하고 header(시작), trailer(끝)에 의미있는 비트를 추가한다. -> Frame (프레임)

데이터 링크층에서 얘기하는 데이터는 Frame. 오직 데이터 링크층에서만 Frame이라고 칭함.

**node-to-node , station-to-station, link-by-link reliable transfer** 가 데이터 링크의 기능이다.

이 기능을 하려면 **주소 지정 (데이터의 주소가 있어야 함), 접근 제어 (누가 접근하는가 등 접근 권한을 제어해야 충돌이 안남), 흐름 제어, 오류처리, 동기화 기능**이 있어야 함

**네트워크층**

발신지에서 목적지까지의 전달을 책임진다.

path(=root)가 너무 다양하기에 어떤 path로 가는 게 좋은지를 판단해서 전달하는 것이 네트워크층 역할임

라우터라고 하는 것은 네트워크층까지 있어야 라우터라고 할 수 있음

논리적인 주소 지정이 있어야 함

물리주소 X, **논리주소** (고정이 안되어있고 변화를 줄 수 있다는 뜻) -> IP주소도 논리주소임

다중화

**패킷이라 부름**

**전송층**

TCP

end-to-end 전달에 대한 책임을 가짐

2계층이랑 좀 비슷한데 목적이 조금 다름

우체통까지가 3번째 계층, **최종 목적지**(ex 엄마)까지가 4번째 계층

**세그먼트 or 데이터그램 이라 부름**

포트(점) 주소 지정

---

### 3장 네트워크층 개요

LAN과 WAN이 서로 연결된 인터넷

x 표시가 교환을 의미

**교환**

메시지를 발신지에서 목적지로 전달하는 과정에서 많은 결정들이 이루어짐

> 회선 교환 (circuit switching)

메시지 전달 전에 발신지와 목적지 사이에 **물리회선 (링크)를 생성한 후** 메시지를 전달한다.

메시지 전달 완료하면 네트워크에 통보 (다 했다) 하면 다른 연결을 위해 연결을 해제한다.

전체 메시지가 패킷(헤더)으로 분할되지 않고 발신지에서 목적지로 전달한다. -> 너, 나가 정해져있으니 내가 누군지 등을 적는 헤더가 필요가 없음

ex) 전화

전화번호를 누르면 송화자와 수화자 사이에 **경로**가 생성되고 수화자가 호출에 응답하면 **회선**이 생성되고 전화를 끊으면 회선의 연결이 **끊어진다.**

근데 전화를 상대방이 안받았을 경우? 회선 낭비됌... 돈을 누구한테 요구? 그래서 패킷 교환이 나오게 됌. 전화가 아닌 문자 등으로도 데이터를 교환하고자 한 것도 패킷 교환이 나오게 된 이유임

> 패킷 교환

오늘날 인터넷 네트워크 계층: 패킷 교환망

발신지에서 목적지까지 **패킷 단위**로 분할

메시지는 관리 가능한 크기의 **패킷으로 분할된 후 송신**되고 목적지에
서 **다시 조립됨 (재조립)**

모든 선을 누구나 쓸 수 있음 (회선 교환은 한사람만 쓸 수 있었음)

사이즈가 너무 짧아도 길어도 문제임. 패킷을 얼만큼 자를 건지.. (패킷 교환에서 고민해야할 사항들)

**데이터그램**

그때그때 좋은 길을 고르는 것

길을 만들 일이 없으니 걍 데이터를 막 다 보냄

**가상회선 (virtual circuit)**

마치 길이 하나밖에 없는 것(회선 교환)처럼 흉내를 내는 것

길이 먼저 만들어지고 데이터는 그 길을 따라 가게 됌 but 모두가 쓸 수 있음 (회선 교환은 한사람만 쓸 수 있다는 게 차이점)

**비연결형 서비스**

연결을 안하고 데이터를 주고받기

데이터 그램임

좋다고 생각하는 길로 보냄. 그래서 처음 보냈을 때랑 결국 도착했을 때랑 순서가 다를 수 있음

네트워크내의 교환기를 라우터라고 함

라우터는 **목적지 주소를 기반**로 패킷을 전달한다. 라우팅 테이블이 있어서 그 테이블 보고 보내줌.

**연결형 서비스**

연결을 하고 데이터를 주고받기

연결 설정, 데이터 전송, 연결 해제의 과정을 거침. (회선 교환과 동일)

데이터그램 송신 전에 경로를 지정하는 가상 회선(virtual circuit)을 생성하고 그 경로에 따라 데이터그램을 전달함 -> 순서가 뒤집힐 일이 없음.
(but 느려질 수 있음, 약간의 딜레이 ~)

패킷에는 가상 회선 식별자(흐름 레이블)가 있어야 함

각 패킷은 레이블을 기반으로 포워딩 결정함.
헤더에 하나가 더 있음. (Incoming 레이블, outgoing 레이블) 레이블이 바뀌면서 감. 목적지 주소를 전혀 안봄 ㄷ ㄷ. 흐름 레이블이 같으면 항상 같은 길로 가게 됌.

라우팅 테이블 (16 페이지)

놀고 있는(안쓰는) label을 넣음. 어떤 port로 내보낼지 정함

받는 컴퓨터가 놀고 있는 label을 응답 메시지로 보냄 그거는 Outgoing label에 들어가게 되면서 라우팅 테이블이 완성된다.

거꾸로 오면서도 label이 들어가게 됌

**논리 주소 체계**

네트워크층은 종단-대-종단 통신을 제공한다.

논리주소라는 인터넷 공통 식별자 시스템이 필요함.

통신을 위해선 네트워크층 주소가 필요함.

## 네트워크층 서비스

**발신지 컴퓨터에서 제공되는 서비스**

패킷화

다음 홉의 논리 주소 찾기: 라우팅 테이블을 참조해서 찾음

논리 주소를 주면 물리 주소를 알려줌

다음 홉의 물리 주소 찾기: ARP(address resolution protocol) 이용해서 찾음

최대 MTU가 얼마냐? 그럼 그 MTU 단위로 쪼가리를 내서 데이터그램을 단편화하게 됌

데이터그램 단편화: 데이터그램이 MTU(maximum transmission unit)보다 클 경우

가장 큰 차량을 MTU라 할 수 있음 즉,**최대 전송 크기**

## 각 라우터에서 제공되는 서비스

두 개 (입력, 출력)의 인터페이스가 관여

다음 홉의 논리주소 찾기

다음 홉의 MAC주소 찾기

단편화

<!-- 내가 가지고 있는 컴은 라우터로 기능할 수 없다.
라우터가 될라면 길 안내를 해야 됌. 즉 최소 두개 이상의 인터페이스가 필요함. -->

## 목적지 컴퓨터에서 제공되는 서비스

단편들을 재조립

상위층에 전달

**재조립 타이머** 설정, 완료 전에 타이머가 만료되면 재전송 오류 메시지를 전송한다. 쪼가리 낸 것들이 올 때까지 기다려주는데 일정시간내에 와야됌. 다 오면 상위 계층에 전달해주면 되는 거고 못오면 재전송하라고 메시지를 전송함 or 버려버림 (얼마나 기다려야 되는 지는 표준으로 정해져 있음)

## 네트워크층의 문제점

길안내 역할로 만들었는데 아래와 같은 문제들이 발생

- 오류 제어

**훼손, 손실, 중복** 데이터그램 탐지 메커니즘
같은 것도 없다.

- 흐름 제어

- 혼잡 제어

- 서비스 품질 (QoS Quality of Service)

네트워크 계층은 서비스 품질을 지원하지 않음

- 라우팅

- 보안

---

> 4장 IP 주소

## 표기법

2진 표기법, 16진 표기법, 점 10진 표기법

► 2진과 점 10진(Dotted-decimal) 표기법

p.5 ~ 7 공부 필요 없음

## 주소의 범위

## 연산

2진법, 10진법을 사용하여 32비트 수에 대한 연산을 수행하는 경우가 있음

-> 비트 단위의 NOT 연산 (일항 연산, unary operation)

## 클래스 기반 주소 지정

IP 주소는 시작할 때 클래스(class) 개념 이용

1990년대 중반에 새로운 구조인 클래스 없는 주소지정(classless addressing) 방법 등장

5개(A, B, C, D, E)의 클래스로 구분

<img width="80%" alt="스크린샷 2024-04-04 오후 5 40 21" src="https://github.com/hanseulhee/studying/assets/63100352/db469e4a-a2eb-4f7c-b1da-fa8d042cc0e9">

---

Octet 의 관심은 오로지 한비트 or 두비트임, 즉 낱개들을 쓸 때는 Byte가 아니라 Octet임

**Netid, hostid**

클래스에 따라 Netid, hostid로 나뉨

**클래스 A**

1바이트만 netid 지정됌

128가지 클래스 A주소를 가질 수 있음

클래스 A 주소는 거의 소진

**클래스 B**

처음 두 바이트가 클래스 지정

클래스 B 주소도 거의 소진

큰 기업 같은 곳에서 사용함

**클래스 C**

처음 세 바이트가 클래스 지정

처음 세 비트는 ‘110’

p.134

블록내의 주소가 73.22.17.25이다. 처음 주소와 마지막 주소를 구하라.

첫번째 바이트는 73이니까 클래스 A주소임. 즉 netid가 73, 뒤에 22.17.25는 hostid고 다 0으로 바꿔서 주어진 주소는 73.0.0.0/8임

첫번째 주소는 hostid에게 줄 수 없음

마지막 주소는 왼쪽 8비트는 유지하고, 오른쪽 24비트는 모두 1로 만든다.마지막 주소는 73.255.255.255임

**네트워크 마스크 (= 디폴트 마스크)**

목적지 주소를 이용하여 네트워크 주소를 찾아내는데 사용

마스크를 이용하여 네트워크 주소 찾아냄 - 목적지 주소와 디폴트 마스크를 AND 연산

## 서브넷팅

클래스 A나 B를 받은 조직이 보안과 관리를 더 잘하기 위해 몇 개의 작은
서브네트워크로 나눌 필요가 있음

서브넷팅에서 각 서브네트워크는 자신의 서브네트워크 주소를 갖는다.

netid의 길이는 증가시키고 hostid의 길이는 감소시킨다.

네트워크를 같은 수의 호스트를 가지는 s개의 서브넷으로 나누면 다음과 같
이 각 서브넷의 subnetid를 구할 수 있다.

<img width="55%" alt="스크린샷 2024-04-09 오후 5 09 07" src="https://github.com/hanseulhee/studying/assets/63100352/1146bed5-fff3-4e77-97a4-b9ce1643ce1b">

---

## 클래스 없는 주소 지정

**블록 할당**

ISP(Internet Service Provider)에 할당

블록 할당 제약 조건(CIDR)

- 요구 주소 N은 2의 거듭제곱이어야 한다
- 블록에 속한 주소의 수(N)로 프리픽스 길이를 알 수 있다
- 할당하는 블록에 속한 주소는 연속적이어야 한다

---

**인터넷 표준**

인터넷 표준은 인터넷을 이용하여 작업하는 사람들에 의해 완전한 시험을 거쳐서 사용되는 규격이다.

인터넷 초안으로 시작되는데 이는 RFC로 발간되며 RFC는 총 6개의 완성 단계를 거친다.

**6개의 완성 단계**: 제안 표준, 초안 표준, 인터넷 표준, 기록 단계, 실험 단계, 정보제공

또한 RFC는 5개의 요구 단계를 거친다.

**5개의 요구 단계**: 요구, 권고, 선택, 사용 제한, 미 권고

-> RFC는 관심을 갖는 모든 사람들에게 이용이 가능하며 완성 단계를 거쳐 요구 단계에 따라 분류된다.

---
