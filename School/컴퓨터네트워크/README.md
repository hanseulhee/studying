# 컴퓨터 네트워크

### 프로토콜

프로토콜이란 통신을 주도하는 **규칙들의 집합**이다.

통신하기 위해서는 반드시 개체들이 프로토콜에 합의해야 한다.

프로토콜은 무엇을, 어떻게, 언제 통신할 것인지를 규정한다.

구문(무엇을), 의미(어떻게), 타이밍(언제) 로 구성되어 있다.

### 표준

정보 통신 표준은 **사실 표준과 법률 표준**으로 구분된다.

법률 표준은 공식적인 권위를 인정받은 단체 혹은 기관에서 제정된 표준, 모두가 동의해야 함

사실 표준은 승인되지는 않았지만 일반에 널리 사용되는 표준을 의미한다.

사실표준은 **특허, 비특허**로 나뉜다.

특허 표준은 원래 자기 제품의 기본 원리를 영리 기관이 창안한 것이다. (=폐쇄 표준: 다른 회사의 제품과 호환이 되지 않기 때문) -> 법적으로 보호됌. 해당 특허 표준을 쓰면 남들은 특허비를 냄

비특허 표준은 원래 집단이나 위원회에서 개발하여 공개 영역에 공개한 표준이다. (=개방 표준: 서로 다른 시스템과의 통신을 개방하기 때문)

사실 표준이 시간이 지나 법률 표준으로 갈 수 있음

### 표준화 기구

**국제 표준화 기구 (ISO)**

OSI (개방 시스템 상호 연경) 모델

**ITU-T**

V 시리즈, X 시리즈 (전화선을 통해 데이터 통신)

**ANSI**

아스키코드 표준, 미국 표준을 제정하는 기관

**IEEE**

LAN (근거리 통신망)

**EIA**

RS-232-C

**NIST**

보안관련 (데이터 암호 표준)

**포럼 (Forum)**

특정 기술 분야에만 전념
광대역 포럼 -> DSL 포럼, ATM 포럼

**W3C**

웹 표준

**KISC (한국 산업 표준원)**

관련된 제품 인증 업무

**KATS(국가 기술 표준원)**

**TTA(한국 정보통신 기술협회)**

**OSIA(개방형 컴퓨터 연구회)**

**한국전자통신연구원 표준연구센터**

### 회선

회선이란 둘 이상의 통신 장치가 하나의 링크에 연결되는 방식

회선 구성 방식은 3가지로 구성되어 있다.

- 점대점

- 다중점

- 교환

**점대점**

1대1, 두 장치만 사용하는 단일 전용 링크

**다중점**

세 개 이상의 장치

전용이 아닌 공유 (ex 버스)

채널 용량을 시간적 또는 공간적으로 공유 (충돌 막는 법) -> 시간적으로 나눠씀 (ex 강의실), 공간적으로 나눠씀 (ex 3501, 3502)

**교환 (스위칭)**

교환기

### 접속형태 (Topology)

- 대등 대 대등 (peer to peer) : 동등하게 링크를 공유 but 충돌 가능성 높음

- 주국 종국 (primary secondary) : 통제하에 통신이 이루어짐

**그물형 (mesh)**

하나의 디바이스는 나머지 디바이스와 다 연결 가능

점대점 전용 링크

n개의 장치를 연결하려면 n(n-1)/2개의 채널이 필요함

단점.

케이블링과 포트 수가 많이 필요, 다 연결되기 때문에 설치와 재구성이 어려움, 비교적 고가임

**성형 (star)**

중간에 허브라는 중앙 제어기가 존재함. 주종관계 성립

허브하고 점대점 링크

허브로 가는 선 한가닥만 있으면 됌

허브가 교환기 역할을 담당함

mesh에 비해 비용이 적게들고 재구성이 쉽고 안정성 굿굿 but 허브가 고장나면 전체가 마비된다.

**트리형 (tree)**

능동적인 허브 active(repeater가 있음), 수동적인 허브 passive(repeater가 없음)로 나뉨

**버스형**

유도선을 이용해 붙이는 방식

제일 끝에 있는 사람은 신호가 작아짐. 그래서 선의 제한이 생김 (무한 x, 충돌 가능성 높음)

근거리 LAN 만들 때 해당 유형 잘 씀

**링형**

**혼합형 (하이브리드)**

다 혼합해서 씀

### 전송 방식

단방향 (일반통행 ex 컴퓨터&키보드), 반이중 (ex 무전기, 묻고답하고), 전이중 (양방향, ex 2차선도로)

전이중으로 갈수록 값은 비싸짐.

### 네트워크 분류

LAN (근거리 통신망), MAN (도시), WAN (국가, 전세계), PAN(개인), BAN(신체)

### 네트워크 간 연결 (Internetworks)

대표적인 것이 router

internet: 개별 네트워크를 상호 연결한 네트워크 총칭

Internet: 전세계적으로 널리 사용되고 있는 **TCP/IP**를
사용하고 있는 특정 네트워크

> 1장 개요 끝

2장

### OSI (Open System Interconnection)

ISO가 만든 OSI 모델로 개방 시스템 상호연결하는 역할을 함

서로 다른 시스템 간에 개방 통신을 위한 것

### OSI 모델 7계층

제1계층: 물리 - 정보가 상대방에게 갈 수 있게 하는 그런 모든 것 (무조건 필요함)

제2계층: 데이터 링크 - 에러를 처리해주는 기능 (에러 복원)

제3계층: 네트워크 - IP 프로토콜이 있던 것

제4계층: 전송

제5계층: 세션

제6계층: 표현 - 압축, 보안 등

제7계층: 응용 - 사용자가 직접 쓰는 것 (web 등)

관련된 계층만 바뀌게 됌. (ex 1단계가 바뀐다? 다 안바꾸고 1단계만 바뀜)

중간에 있는 네트워크 장비들은 굳이 모든 걸 알 필요 없음. 3번째까지만 통신기능 있음

**peer-to-peer(대등-대-대등)** 프로세스

해당 계층에서 통신하는 각 시스템의 프로세스 (동급, 대동한 애끼리 얘기하는 거)

**계층간 인터페이스**

계층과 계층 사이에는 인터페이스가 존재함

아래쪽은 위쪽한테 기능을 제공함, 위쪽은 아래의 서비스를 이용함

위쪽은 인터페이스가 바뀌는 것 이외에는 관심없음

즉 하나의 계층은 자기 밑에 있는 애(서비스 사용함), 자기 위에 있는 애(서비스 제공해야됌), peer to peer (건너편 동일한 애) 이 3가지의 일을 함

계층 1, 2, 3 - 네트워크 지원 계층

계층 5, 6, 7 - 사용자 지원 계층

계층 4 - 전송 계층

H2에 오면 꼬리가 붙임. 2단계가 구조가 좀 다름 (이질적인 요소 등이 포함)
2단계는 데이터가 깨진 걸 복원하는 역할을 해야하기에 정보가 많아짐 (H2에 추가비트 즉 비용을 좀 지불함)
그 다음 1단계에 주면 1010101 식으로 됌.

1단계 그다음 나가는 것은 데이터가 아닌 전송 매체임 그다음 시스템에게 전달할 시 다시 데이터로 바꿈
안깨졌는 지 확인하고 깨졌으면 이전 시스템에게 다시 줌 (이를 반복하고 성공 시 제대로 전달)

**송신쪽에서는 헤더가 늘어가면서 내려가고 수신쪽에서는 헤더가 줄어들면서 올라감**

ex

H4가 H3을 볼 수 있으면 일이 더 빨리질 수 있음 (무슨 일이 일어나는 지 아니깐) but H4는 수신쪽 애랑 약속한 것임. 그래서 H4가 바뀌면 H3도 바뀌어야 함. 이에 독립적이지 못하기에 **절대 보면 안됌**. 그 순간에는 편할 지 몰라도 굉장히 안좋게 됌.

### 계층별 기능

**물리층**

물리적인 매체를 통해 비트 흐름을 전송하기 위해 요구되는 기능을 제어하는 곳

**기계적, 전기적 특성을 여기서 다 다룸** (ex 케이블의 두께 등)

데이터 링크층으로부터 데이터를 받아 **전송될 수 있는 형태로 변환**

비트 스트림을 **전자기 신호로 변환**

신호 전송이 잘되고 있는 지 관리 감독함 (연달아 1이 계속오네 ? 문제가 있네 하고 처치를 진행함)

물리적으로 다 연결되어야 하니 이를 고려해야함

**데이터 링크층**

깨진 데이터를 복원하여 오류 없는 데이터 전달에 대한 책임을 가지는 곳 (reliable transfer)

세번째 계층으로부터 데이터를 받아서 주소와 제어벙보를 포함하고 header(시작), trailer(끝)에 의미있는 비트를 추가한다. -> Frame (프레임)

데이터 링크층에서 얘기하는 데이터는 Frame. 오직 데이터 링크층에서만 Frame이라고 칭함.

**node-to-node , station-to-station, link-by-link reliable transfer** 가 데이터 링크의 기능이다.

이 기능을 하려면 **주소 지정 (데이터의 주소가 있어야 함), 접근 제어 (누가 접근하는가 등 접근 권한을 제어해야 충돌이 안남), 흐름 제어, 오류처리, 동기화 기능**이 있어야 함

**네트워크층**

발신지에서 목적지까지의 전달을 책임진다.

path(=root)가 너무 다양하기에 어떤 path로 가는 게 좋은지를 판단해서 전달하는 것이 네트워크층 역할임

라우터라고 하는 것은 네트워크층까지 있어야 라우터라고 할 수 있음

논리적인 주소 지정이 있어야 함

물리주소 X, **논리주소** (고정이 안되어있고 변화를 줄 수 있다는 뜻) -> IP주소도 논리주소임

다중화

**패킷이라 부름**

**전송층**

TCP

end-to-end 전달에 대한 책임을 가짐

2계층이랑 좀 비슷한데 목적이 조금 다름

우체통까지가 3번째 계층, **최종 목적지**(ex 엄마)까지가 4번째 계층

**세그먼트 or 데이터그램 이라 부름**

포트(점) 주소 지정

---

### 3장 네트워크층 개요

LAN과 WAN이 서로 연결된 인터넷

x 표시가 교환을 의미

**교환**

메시지를 발신지에서 목적지로 전달하는 과정에서 많은 결정들이 이루어짐

> 회선 교환 (circuit switching)

메시지 전달 전에 발신지와 목적지 사이에 **물리회선 (링크)를 생성한 후** 메시지를 전달한다.

메시지 전달 완료하면 네트워크에 통보 (다 했다) 하면 다른 연결을 위해 연결을 해제한다.

전체 메시지가 패킷(헤더)으로 분할되지 않고 발신지에서 목적지로 전달한다. -> 너, 나가 정해져있으니 내가 누군지 등을 적는 헤더가 필요가 없음

ex) 전화

전화번호를 누르면 송화자와 수화자 사이에 **경로**가 생성되고 수화자가 호출에 응답하면 **회선**이 생성되고 전화를 끊으면 회선의 연결이 **끊어진다.**

근데 전화를 상대방이 안받았을 경우? 회선 낭비됌... 돈을 누구한테 요구? 그래서 패킷 교환이 나오게 됌. 전화가 아닌 문자 등으로도 데이터를 교환하고자 한 것도 패킷 교환이 나오게 된 이유임

> 패킷 교환

오늘날 인터넷 네트워크 계층: 패킷 교환망

발신지에서 목적지까지 **패킷 단위**로 분할

메시지는 관리 가능한 크기의 **패킷으로 분할된 후 송신**되고 목적지에
서 **다시 조립됨 (재조립)**

모든 선을 누구나 쓸 수 있음 (회선 교환은 한사람만 쓸 수 있었음)

사이즈가 너무 짧아도 길어도 문제임. 패킷을 얼만큼 자를 건지.. (패킷 교환에서 고민해야할 사항들)

**데이터그램**

그때그때 좋은 길을 고르는 것

길을 만들 일이 없으니 걍 데이터를 막 다 보냄

**가상회선 (virtual circuit)**

마치 길이 하나밖에 없는 것(회선 교환)처럼 흉내를 내는 것

길이 먼저 만들어지고 데이터는 그 길을 따라 가게 됌 but 모두가 쓸 수 있음 (회선 교환은 한사람만 쓸 수 있다는 게 차이점)

**비연결형 서비스**

연결을 안하고 데이터를 주고받기

데이터 그램임

좋다고 생각하는 길로 보냄. 그래서 처음 보냈을 때랑 결국 도착했을 때랑 순서가 다를 수 있음

네트워크내의 교환기를 라우터라고 함

라우터는 **목적지 주소를 기반**로 패킷을 전달한다. 라우팅 테이블이 있어서 그 테이블 보고 보내줌.

**연결형 서비스**

연결을 하고 데이터를 주고받기

연결 설정, 데이터 전송, 연결 해제의 과정을 거침. (회선 교환과 동일)

데이터그램 송신 전에 경로를 지정하는 가상 회선(virtual circuit)을 생성하고 그 경로에 따라 데이터그램을 전달함 -> 순서가 뒤집힐 일이 없음.
(but 느려질 수 있음, 약간의 딜레이 ~)

패킷에는 가상 회선 식별자(흐름 레이블)가 있어야 함

각 패킷은 레이블을 기반으로 포워딩 결정함.
헤더에 하나가 더 있음. (Incoming 레이블, outgoing 레이블) 레이블이 바뀌면서 감. 목적지 주소를 전혀 안봄 ㄷ ㄷ. 흐름 레이블이 같으면 항상 같은 길로 가게 됌.

라우팅 테이블 (16 페이지)

놀고 있는(안쓰는) label을 넣음. 어떤 port로 내보낼지 정함

받는 컴퓨터가 놀고 있는 label을 응답 메시지로 보냄 그거는 Outgoing label에 들어가게 되면서 라우팅 테이블이 완성된다.

거꾸로 오면서도 label이 들어가게 됌

**논리 주소 체계**

네트워크층은 종단-대-종단 통신을 제공한다.

논리주소라는 인터넷 공통 식별자 시스템이 필요함.

통신을 위해선 네트워크층 주소가 필요함.

## 네트워크층 서비스

**발신지 컴퓨터에서 제공되는 서비스**

패킷화

다음 홉의 논리 주소 찾기: 라우팅 테이블을 참조해서 찾음

논리 주소를 주면 물리 주소를 알려줌

다음 홉의 물리 주소 찾기: ARP(address resolution protocol) 이용해서 찾음

최대 MTU가 얼마냐? 그럼 그 MTU 단위로 쪼가리를 내서 데이터그램을 단편화하게 됌

데이터그램 단편화: 데이터그램이 MTU(maximum transmission unit)보다 클 경우

가장 큰 차량을 MTU라 할 수 있음 즉,**최대 전송 크기**

## 각 라우터에서 제공되는 서비스

두 개 (입력, 출력)의 인터페이스가 관여

다음 홉의 논리주소 찾기

다음 홉의 MAC주소 찾기

단편화

<!-- 내가 가지고 있는 컴은 라우터로 기능할 수 없다.
라우터가 될라면 길 안내를 해야 됌. 즉 최소 두개 이상의 인터페이스가 필요함. -->

## 목적지 컴퓨터에서 제공되는 서비스

단편들을 재조립

상위층에 전달

**재조립 타이머** 설정, 완료 전에 타이머가 만료되면 재전송 오류 메시지를 전송한다. 쪼가리 낸 것들이 올 때까지 기다려주는데 일정시간내에 와야됌. 다 오면 상위 계층에 전달해주면 되는 거고 못오면 재전송하라고 메시지를 전송함 or 버려버림 (얼마나 기다려야 되는 지는 표준으로 정해져 있음)

## 네트워크층의 문제점

길안내 역할로 만들었는데 아래와 같은 문제들이 발생

- 오류 제어

**훼손, 손실, 중복** 데이터그램 탐지 메커니즘
같은 것도 없다.

- 흐름 제어

- 혼잡 제어

- 서비스 품질 (QoS Quality of Service)

네트워크 계층은 서비스 품질을 지원하지 않음

- 라우팅

- 보안

---

> 4장 IP 주소

## 표기법

2진 표기법, 16진 표기법, 점 10진 표기법

► 2진과 점 10진(Dotted-decimal) 표기법

p.5 ~ 7 공부 필요 없음

## 주소의 범위

## 연산

2진법, 10진법을 사용하여 32비트 수에 대한 연산을 수행하는 경우가 있음

-> 비트 단위의 NOT 연산 (일항 연산, unary operation)

## 클래스 기반 주소 지정

IP 주소는 시작할 때 클래스(class) 개념 이용

1990년대 중반에 새로운 구조인 클래스 없는 주소지정(classless addressing) 방법 등장

5개(A, B, C, D, E)의 클래스로 구분

<img width="80%" alt="스크린샷 2024-04-04 오후 5 40 21" src="https://github.com/hanseulhee/studying/assets/63100352/db469e4a-a2eb-4f7c-b1da-fa8d042cc0e9">

---

Octet 의 관심은 오로지 한비트 or 두비트임, 즉 낱개들을 쓸 때는 Byte가 아니라 Octet임

**Netid, hostid**

클래스에 따라 Netid, hostid로 나뉨

**클래스 A**

1바이트만 netid 지정됌

128가지 클래스 A주소를 가질 수 있음

클래스 A 주소는 거의 소진

**클래스 B**

처음 두 바이트가 클래스 지정

클래스 B 주소도 거의 소진

큰 기업 같은 곳에서 사용함

**클래스 C**

처음 세 바이트가 클래스 지정

처음 세 비트는 ‘110’

p.134

블록내의 주소가 73.22.17.25이다. 처음 주소와 마지막 주소를 구하라.

첫번째 바이트는 73이니까 클래스 A주소임. 즉 netid가 73, 뒤에 22.17.25는 hostid고 다 0으로 바꿔서 주어진 주소는 73.0.0.0/8임

첫번째 주소는 hostid에게 줄 수 없음

마지막 주소는 왼쪽 8비트는 유지하고, 오른쪽 24비트는 모두 1로 만든다.마지막 주소는 73.255.255.255임

**네트워크 마스크 (= 디폴트 마스크)**

목적지 주소를 이용하여 네트워크 주소를 찾아내는데 사용

마스크를 이용하여 네트워크 주소 찾아냄 - 목적지 주소와 디폴트 마스크를 AND 연산

## 서브넷팅

클래스 A나 B를 받은 조직이 보안과 관리를 더 잘하기 위해 몇 개의 작은
서브네트워크로 나눌 필요가 있음

서브넷팅에서 각 서브네트워크는 자신의 서브네트워크 주소를 갖는다.

netid의 길이는 증가시키고 hostid의 길이는 감소시킨다.

네트워크를 같은 수의 호스트를 가지는 s개의 서브넷으로 나누면 다음과 같
이 각 서브넷의 subnetid를 구할 수 있다.

<img width="55%" alt="스크린샷 2024-04-09 오후 5 09 07" src="https://github.com/hanseulhee/studying/assets/63100352/1146bed5-fff3-4e77-97a4-b9ce1643ce1b">

---

## 클래스 없는 주소 지정

**블록 할당**

ISP(Internet Service Provider)에 할당

블록 할당 제약 조건(CIDR)

- 요구 주소 N은 2의 거듭제곱이어야 한다
- 블록에 속한 주소의 수(N)로 프리픽스 길이를 알 수 있다
- 할당하는 블록에 속한 주소는 연속적이어야 한다

**슬래시 표기법**

프리픽스 길이를 주소에 포함하여 표현한다.

**서브넷팅**

3단계 계층은 서브넷팅을 이용하여 구성한다.

예제 4.23

기관에 블록 130.34.12.64/26이 할당 되었다. 기관은 각각 동일한 개수의 호
스트를 갖는 4개의 서브넷을 구성하고자 한다. 서브넷을 설계하고 각 서브넷에
대한 정보를 구하여라

32-26을 빼서 2에 6승 = 64가 됌.ㄴ 즉 이 기관에는 64개의 ip 주소가 할당.

**주소 결합**

**특수 주소**

클래스 기반 주소지정에서, 일부 주소는 특수 목적을 위해 예약되어 있다.

클래스 없는 주소지정에서도 동일하게 클래스 기반 주소지정
방식과 동일한 특수 주소가 있다.

**모두-0인 주소**

맨처음 나는 ip 주소가 없음. 그래서 내가 누구라고 말을 할 수 없음 (내가 누군지 몰라)

이때 쓰는 것이 모두 0 (발신지 0.0.0.0)

발신지 주소에서만 이용함

나도 모르는 주소를 DHCP 서버가 알려주게 됌
DHCP 서버한테 나 주소하나 줘. 하면 DHCP가 줌. but 아무나에게 주지는 않음. 따라서 부트스트랩 시간에

문제는 발신지(나)도 모르고 목적지도 모름. 그럴 때 목적지 주소는 **제한된** 브로드캐스트 주소임. 즉 그 네트워크 내에서 제한된 주소임

**모두-1인 주소: 제한된 브로드캐스트 주소**

누군가 보내면 네트워크 안에 있는 모든 기기에게 다 감.

제한된 목적지 네트워크 안에서만 방송하고 다른 곳으로 이동하지 못함 (이걸 안막으면 인터넷 홍수나게 됌)

**루프백 주소**

127.0.0.0/8

컴퓨터에 설치된 소프트웨어를 시험하기 위하여 사용되는 주소

ex) 채팅 프로그램을 짜는데 그러한 하드웨어말고 오로지 소프트웨어 기능만 하고 싶어.

127로 시작하는 주소는 루프백 주소임

**사설 주소**

사설 용도를 위하여 할당 (ex 공유기)

ex) 옆집에 있는 아기 이름과 우리집에 있는 아기 이름이 같아도 상관없음. 아무 문제 없음

ex) 학교안에서 공유기 등은 다 사설 주소임

전역 네트워크에서 인식되지 않음

네트워크가 분리되어 있거나 주소 변환 기술(NAT)를 사용하여 사설망을 인터넷에 연결하는데 사용

**멀티캐스트 주소**

그룹주소임.

224.0.0.0/4 블록

멀티캐스트 통신을 위해 예약된 블록

## 블록에 속하는 특수 주소

블록에 속하는 일부 주소를 특수 주소로 사용

호스트에게 할당 불가임.

블록에 속하는 첫번째 주소인 네트워크 주소는 전체를 대변하는 주소임 따라서 줄 수 없음

직접 브로드캐스트 주소도 줄 수 없음.

**네트워크 주소**

클래스 주소에서 hostid가 모두 ‘0’인 주소

**직접 브로드캐스트 주소**

서픽스가 모두 1인 주소

패킷에서 목적지 주소로만 사용된다.

## 특수 주소 정리

<img width="80%" alt="스크린샷 2024-04-11 오후 5 31 07" src="https://github.com/hanseulhee/studying/assets/63100352/439014dd-d609-4620-bf10-e85e9d3d0aeb">

---

## IP 패킷 전달과 포워딩 (5장)

**연결형 서비스**

발신지의 네트워크층 프로토콜은 패킷을 보내기 전에 먼저 목적지의 네
트워크층 프로토콜과 연결을 설정한다.

연결이 설정되면 발신지에서 목적지로 가는 패킷들은 순서대로 하나씩
보내고 모든 패킷은 같은 경로를 통해 전달된다.

메시지에 속한 모든 패킷이 전달되면 연결이 해제된다.

**비연결형 서비스**

각 패킷은 서로 독립적으로 처리한다.

패킷들 사이에 아무런 관계가 없으며 하나의 메시지에 속한 패킷들은
같은 목적지에 전달되더라도, 서로 다른 경로로 전달될 수 있다.

IP 프로토콜은 원래는 비연결형으로 설계된다.

**직접 전달**

내가 데이터를 보내는 호스트랑 받는 호스트가 같은 네트워크에 있음 (직접 물리적으로 연결되어있음)

ARP 이용

**간접 전달**

최종 목적지가 같은 네트워크에 있지 않은 호스트

최종 목적지 호스트와 같은 네트워크에 연결된 라우터에 도달 할 때
까지 여러 라우터를 경유해서 전달한다. 목적지 IP 주소와 라우팅 테이블을 이용하여 패킷이 전달되어야 하는 다음 라우터의 IP 주소를 찾는다.

목적지 말고 거쳐갈 라우터를 찾아야 함.

**포워딩**

패킷을 목적지로 가는 경로상에 올려놓는 것을 의미한다.

패킷을 다음 홉으로 전달하는 것을 의미한다.

홉(hop)은 최종 목적지 또는 중간 연결 장치를 의미한다. 다음 홉(=목적지)이다.

**목적지 주소 기반 포워딩 기술**

다음-홉(next-hop) 방법

네트워크-지정(network-specific) 방법

호스트 지정(host-specific) 방법

디폴트(default) 방법

    N2에 연결된 호스트들에 패킷을 보내기 위해서는 라우터 R1 이용한다.

    나머지 호스트들에 대해서는, 인터넷상의 모든 네트워크를 나열하는 대신 네트워크 주소가 0.0.0.0인 디폴트 엔트리만 지정

---

p.184

## 포워딩

**클래스 없는 주소지정에서 포워딩**

- 클래스 없는 주소지정에서 전체 주소 공간은 한 개의 개체(클래스 x)이다.

- 포워딩은 각 블록 별로 한 줄의 정보를 필요로 한다는 것을 의미한다.

- 테이블은 네트워크 주소(블록의 첫 번째 주소)에 기반하여 탐색되어야 한다.

- 테이블에 마스크(/n)를 포함하여야 한다.

- 테이블은 적어도 네 개의 열이 필요하다.

마스크에 따라 네트워크 주소가 달라짐

마스크의 순서가 뒤집히면 라우팅이 제대로 안됌

**주소 집단화**

- 테이블 크기가 증가하고 탐색 시간 증가를 완화하기 위해

**가장 긴 마스크 부합**

- 마스크 길이가 긴 것부터 부합 적용(1기관이 떨어져 있는 경우 나머지 3
  개의 주소 집단화 적용 가능)

**계층적 라우팅**

- 라우팅 테이블의 크기가 커지는 문제를 해결하기 위해 도입

- 인터넷을 백본, 지역, 로컬로 나누는 것처럼 계층구조 개념 도입

**지리적 라우팅**

- 라우팅 테이블의 크기를 더욱 축소하기 위하여

- 국가간 라우팅을 위한 라우팅 테이블에 한 개의 엔트리 사용

**클래스 기반 주소지정에서 탐색**

- 클래스 기반 주소지정에서 라우팅 테이블은 리스트 구조로 되어 있다.

- 그러나 탐색을 더욱 효율적으로 만들기 위하여 라우팅 테이블은 각 클래스 당 한개씩 전부 세 개의 테이블(버킷이라고도 부름)로 나눌 수 있다.

- 패킷이 도착하면 라우터는 디폴트 마스크를 적용하여 A, B 또는 C 중 해당하는 버킷을 찾는다.

- 다음 전체 테이블 대신 해당하는 버킷 내에서 탐색이 수행된다.

**클래스 없는 주소지정에서 탐색**

**레이블 기반 포워딩**

라우팅을 교환으로 대치하여 IP를 연결형 프로토콜처럼 동작하도록 하고자 하는 시도

번호표를 들고와서 교환 테이블(아주 심플하게 생김)에 해당하는 곳으로 감 갯수가 많아도 번호표대로 가면 되서 시간이 오래 안걸림. 내보낼 때 레이블만 바꿔서 스위치에서 내보낸다. 기계적임 (= 하드웨어로 만들 수 있음)

but 번호표를 누가 언제 만드는가? 데이터를 보낼 때 번호를 붙여서 보냄. 그럼 송신자에게는 번호가 전해져있음

**MPLS**

이전에는 ip 주소로 데이터를 주고 받는데 시간이 너무 오래 걸림. 이에 다 안거쳐도 직통으로 가는 방법임. 그래서 돈을 더 내야함 (ex 급행)

## 라우터 구조

**입력 포트**

레이어 2까지 커버함

보장해서 목적지까지 가야하는데 잃어버릴 수 있음. 너무 많은 데이터가 오면 버릴 수 밖에 없기 때문. 그래서 안깨졌지만 목적지까지 못갈 수 있음

**출력 포트**

**라우팅 처리기**

목적지 주소를 사용하여 다음 홉 주소를 찾고 동시에 패킷이 전송될 출력
포트 번호도 결정함

**교환 조직**

패킷을 입력 큐에서 출력 큐로 이동

크로스바 교환기, 배년 교환기, 배처-배년 교환기라는 게 있다라는 정도만 알기

---

(기말)

## 와이어샤크 및 설치와 실행

### 패킷 분석기

**네트워크 분석**

패킷이 오고가는 데 그 중간을 따서 볼 수 있는 것, 도청기임. 그중에 대표적인 게 와이어샤크다.

이걸 하려면 TCP/IP 에 대해 이해할 줄 알아야하며, 와이어샤크 사용법, 패킷 구조와 흐름을 알아야 함

**패킷 분석기**

덤프 분석

도청하거나 악용하면 법률로 처벌받음. but 사실 기능을 보면 걍 도청하는 것임

**패킷 분석기 종류**

값이 비싼 건 진짜 비쌈

하드웨어 분석기와 소프트웨어 분석기로 나뉨.

소프트웨어 분석기 중 대표적인 게 와이어샤크.

### 와이어샤크

오픈 소스임

프로토콜 학습하기 위해 사용, 네트워크 트러블 슈팅에 사용.

캡처해서 본다가 와이어샤크의 주요 기능임.

(p.43 이전까지 안봐도 됩니다.)

<img width="814" alt="스크린샷 2024-04-30 오후 5 24 04" src="https://github.com/hanseulhee/studying/assets/63100352/2a06ac1b-0391-460b-8257-d6a8020c3ddb">

헤더 length는 곱하기 5를 해야함.

(7장 스킵)

## 임의 접근

경쟁 방식이다

나하고 싶은 말 있음 하면 된다. 근데 둘이 동시에 말하면 충돌이 남. 누구를 제어하거나 당할 수 없음. 모두 똑같은 권리를 갖는다

MA

CSMA -> 충돌이 발생해도 충돌이 된지 몰라서 그냥 하던대로 말하는 것.

CSMA/CD (유선 통신) -> 데이터를 보내다가 충돌을 감지해서 전송을 멈춤. 충돌하면 다 깨졌으니 보낼 필요가 없음. 종료.
유선은 에너지 레벨이 거의 줄지 않음.

비지속: 누가 쓰고있네? 일정 시간 뒤 감지 (non persistent)

p-지속성: 확률. 랜덤숫자로 진행. 근데 누가 쓰고 있으면 일정 시간 뒤 다시함. 랜덤숫자 또 생성. 그 숫자만큼 내로 들어왔다면 완료 (p-persistent)

CSMA/CA (무선 통신) -> 충돌을 감지할 수가 없음. 충돌 자체를 회피함. 애초에 충돌이 안되게 만든다.

how? 프레임간 공간, 경쟁구간, 확인응답 이 세가지 전략에 의해 회피한다.

누가 말을 하면 계속 확인하다가 아무도 안쓰면 IFS. 사실상 낭비지만 충돌이 안나기 위해 하는 것임. IFS를 다르게 줌으로써 우선순위를 갖게 됌.

경쟁 구간은 2진 지수적으로 증가한다. 충돌이 발생하면 2배로 늘림.

무선에서는 노이즈가 너무 많아서 구별이 안된다. 확인할 방법이 없음. 즉, 경쟁하는 애들이 많구나라고 예측만함. IFS로 우선순위를 조절하고 랜덤넘버를 발생시켜서 작은 숫자인 애가 우선순위가 높도록 설정함. 가장 오래 기다린 지국이 우선순위를 갖는다.

CTS안에 "나 얼마정도 시간 쓸꺼야"라는 걸 넣어서 NAV에 넣음 (예약한셈)

잘 받았다고 응답을 보냄.

응답이 안오면 무슨 일이 났구나 하는 것임

## 제어 접근

폴링
-> 주국과 종국. 주국이 중앙제어기다. 종국은 응답만 가능함.

채널화
-> 서로 다른 주파수를 쓰는 것.

TDMA
-> 시간을 나눈다. 채널은 하나인데 시간을 나눔으로써 충돌을 방지한다.

아이디어
-> 모든 공간, 모든 시간을 모든 사람이 쓴다. 코드값을 알면 값을 알 수 있음. **칩스**: 일련의 숫자 열.

**수열 생성**: 윌쉬 표의 생성에 대한 일반 법칙과 예

시간을 나누던지, 주파수를 나누던지인줄알았는데 이러한 방법도 창출해냄

## 근거리 통신망: 유선 이더넷 (8장)

Ethernet II 프레임은 6개의 필드로 구성
-> 프리엠블(preamble), 목적지 주소(DA), 발신지 주소(SA), 이더넷 유형, 상위 계층 데이터, FCS

Ethernet II는 프레임의 확인응답 메커니즘은 미제공. 확인응답은 상위 계층에서 구현되어야 함.

## 패킷에 대한 덤프 분석

- Destination: 수신자 MAC 주소 필드(6바이트)

  ff:ff:ff:ff:ff:ff 설정, 브로드캐스트 주소

- Source: 송신자 MAC 주소

  00:0c:f8:14:a2:04로 설정

  앞 3바이트: 제조사명(OUI), 뒤 3바이트: 제조 일련번호

  OUI : Organizational Unique Identifier

- Type

  Ethernet II 헤더 다음에 이어지는 캡슐화 형식을 2바이트로 지정 부분

---

## 주소 변환 프로토콜(ARP) (9장)

IP 주소는 논리주소다. 물리주소를 알기 위해서는 논리주소를 물리주소로 변환해야 하는데 이것을 해주는 것을 ARP라고 한다.

논리주소는 네트워크 계층 주소이며 32비트이다. 물리주소는 로컬에서만 유효하면 되는 주소이다.

ARP은 요청하는 곳, 요청 받는 곳으로 구성되어 있음 (아주 간단)

요청은 브로드캐스트, 응답은 유니캐스트이다. (내 정보를 다 주기 때문에 가능)

**ARP가 사용되는 4가지 경우**

- 송신자는 호스트이고 같은 네트워크상에 다른 호스트에 패킷 전송(논리 주소는 목적지 IP주소)

- 송신자는 호스트이고 다른 네트워크상에 있는 어떤 호스트에게 패킷 전송(논리 주소는 라우터의 IP 주소)

- 다른 네트워크상에 있는 호스트로 가는 데이터그램을 수신한 라우터가 송신자(논리 주소는 다음 홉 라우터의 IP 주소)

- 같은 네트워크 상에 있는 호스트로 가는 데이터그램을 수신한 라우터가 송신자(논리 주소는 목적지 IP 주소)

---

(10장)

## 인터넷 프로토콜

인터넷 프로토콜이란 TCP/IP 프로토콜이 사용하는 전송 메커니즘으로 신뢰성이 없고 최선의 노력으로 전달 서비스 제공 (할 수 있는 한 최선을 다하는데 환경이 별로면 그냥 버린다는 뜻)

데이터그램 방식을 사용하는 패킷 교환망을 위해 설계된 비연결형 프로토콜 (그때그때 좋은 방향으로 가는 것. 미리 정해진 연결은 없음 이에 수신쪽 순서가 뒤죽박죽 될 수 있다.)

## 데이터그램

IP 계층의 패킷을 데이터그램이라고 한다.

헤더와 데이터 부분으로 구성되어 있으며 라우팅과 전달에 필요한 정보를 포함한다.

Time to live : 목적지까지 얼만큼의 라우터를 거칠치에 대해 2배 정도 곱해준다. (길을 잃어도 도착할 수 있게.) 깨지면 그냥 버려버림 - 비신뢰성

길을 갔을 때 제한 사항이 있을수도? 그럼 그 상황에 맞게 가는데 어느정도 규칙은 지켜야 함 -> Options + padding

헤더는 4비트로 구성된다. 옵션이 추가되지 않은 헤더는 20바이트, 추가된 경우는 최대 60바이트

최소 20은 되어야 하기에 그 미만이면 깨진 거라고 본다.

**식별 (id)**

16비트로 구성. 단편화를 위하여 사용하며 호스트가 보낸 각 데이터그램을 유일하게 식별한다.

보낸 순서대로 오지도 않고 더 쪼가리가 되어 옴. 이걸 어떻게 다시 합칠꺼냐? 그래서 헤더 필드가 있어야 한다. 우선 id 자리가 똑같으면 다 같은 필드였다라는 걸 증명한다. (고유한 성질)

---

**인터넷 표준**

인터넷 표준은 인터넷을 이용하여 작업하는 사람들에 의해 완전한 시험을 거쳐서 사용되는 규격이다.

인터넷 초안으로 시작되는데 이는 RFC로 발간되며 RFC는 총 6개의 완성 단계를 거친다.

**6개의 완성 단계**: 제안 표준, 초안 표준, 인터넷 표준, 기록 단계, 실험 단계, 정보제공

또한 RFC는 5개의 요구 단계를 거친다.

**5개의 요구 단계**: 요구, 권고, 선택, 사용 제한, 미 권고

-> RFC는 관심을 갖는 모든 사람들에게 이용이 가능하며 완성 단계를 거쳐 요구 단계에 따라 분류된다.

---
