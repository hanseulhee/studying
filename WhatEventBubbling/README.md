# What Event Bubbling

뭐야 ? 뭐야 ? 이건 뭐야 ?

## CSR / SSR

<img src="https://velog.velcdn.com/post-images%2Fhaileyself%2F0bdc5620-2149-11ea-bc09-3b1f344ad048%2Fimage.png" width="80%" />

### CSR

Client-side Rendering으로 **클라이언트 측에서 [렌더링](#렌더링)** 하는 것이다.

서버에서 전체 페이지 (빈 페이지) 를 한번 렌더링하여 보여주고 이후 사용자가 요청할 때마다 리소스를 서버에서 제공받아 클라이언트가 해석하고 렌더링하는 방식이다.

1. 사용자가 사이트에 처음 접속하면 클라이언트는 이를 확인하고 서버에 요청한다.

2. 응답받은 서버는 빈 페이지를 클라이언트에게 전달한다.

3. 전달받은 클라이언트는 해당 화면을 그려주고 스크립트를 다운로드 해 최종적인 화면을 사용자에게 보여준다.

### CSR의 장단점

**장점**

초기 로딩 후 서버에 재요청을 할 필요 없이 클라이언트 내에서 작업이 이뤄지므로 속도가 빠르다. ( = 후속 페이지 로드 시간이 빠르다.)

**단점**

[SEO](#seo)에 취약하다. 검색 엔진 크롤러가 해당 페이지에 처음 방문했을 때 빈 페이지이기 때문에 이해할 수 없다.

페이지를 읽어들이는 시간, 자바스크립트를 읽어들이는 시간, 자바스크립트가 화면을 그리는 시간까지 모두 마쳐야 사용자에게 보여지므로 SSR에 비해 초기 구동 속도가 느리다.

### SEO

SEO(Search Engine Optimization)는 웹 페이지 검색엔진이 자료를 수집하여 검색 결과의 상위에 나올 수 있도록 하는 작업이다.

검색했을 때 결과가 사용자에게 많이 노출될 수 있도록 한다.

### SSR

Server-side Rendering 으로 **서버 측에서 [렌더링](#렌더링)** 하는 것이다.

서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다.

즉 서버측에서 렌더링 준비가 다 끝난 채로 사용자에게 전달된다. 페이지를 이동할 때마다 새로운 페이지를 요청한다.

1. 사용자가 사이트에 처음 접속하면 클라이언트는 이를 확인하고 서버에 요청한다.

2. 응답받은 서버는 데이터를 포함한 미리 만들어둔 정적 파일을 클라이언트에게 전달한다.

3. 전달받은 클라이언트에서 스크립트가 수행하여 해 최종적인 화면을 사용자에게 보여준다.

### SSR의 장단점

**장점**

페이지를 구성하는 속도는 CSR보다 늦지만 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라진다 (= 초기 로딩 속도가 빠르다.)

서버에서 한 번에 웹의 정보를 HTML로 받아오기 때문에 검색 엔진이 페이지를 크롤링하기에 적합하여 SEO에 유리하다.

**단점**

새로운 요청이 있을때마다 페이지 전체를 다시 구성해야한다.
(페이지 요청마다 페이지 새로고침이 발생한다.)

<img src="https://velog.velcdn.com/images/yejine2/post/b03fd089-9b7d-49d8-a408-55c3c543d838/image.png" width="80%" />

### SPA

싱글 페이지 어플리케이션(Single Page Application)은 말 그대로 하나의 페이지로 구성된 웹 어플리케이션이다.

SPA가 등장하기 전 웹 어플리케이션은 여러 페이지([MPA](#mpa))로 구성되었다. 그러나 시간이 흐르면서 웹은 더 많은 정보를 제공하게 되었고 모바일 기기를 통한 웹 어플리케이션 접속도 증가하였다.

MPA의 속도 저하를 처음 접근 시 웹 어플리케이션에 필요한 모든 정적 리소스를 단 한번만 다운로드하고 이후 필요한 데이터만 변경하여 사용할 수 있는 SPA로 해결하고자 하였다.

### SPA의 장단점

**장점**

화면 구성에 필요한 모든 HTML은 클라이언트가 가지고 있고 필요한 데이터만 서버에 요청해서 받기 때문에 새로고침을 할 필요도 없고 화면을 구성하는 속도가 빠르다.

페이지를 이동 하더라도 필요한 부분 (컴포넌트)만 부분적으로 교체하면 되므로 효율성이 증가한다.

서버가 해야 할 화면 구성을 클라이언트가 수행하므로 서버 부담이 경감된다.

사용자의 요청에 빠르게 반응한다.

**단점**

- 초기 구동 속도가 느리다.

최초 접근 시 필요한 정적 리소스를 한번에 다운로드 하기 때문에 초기 구동 속도가 상대적으로 느리다.

- SEO에 취약하다.

검색 엔진이 크롤링할 때 서버로부터 빈 HTML을 내려받기 때문에 제대로 크롤링하지 못한다.
(구글 검색 엔진은 괜찮을 수 있으나 국내 검색 엔진은 제대로 이루어지지 않는다.)

### MPA

멀티 페이지 어플리케이션(Multiple Page Application)은 말그대로 여러개의 페이지로 이루어진 어플리케이션이다.

MPA는 전통적인 웹 애플리케이션 개발 방식으로 웹 브라우저에서 특정 페이지에 대한 요청을 서버에 보내면 서버는 데이터를 HTML 문서로 웹 브라우저에 응답해준다. 이 때 전체 페이지가 다시 불러와지게 된다.

### MPA의 장단점

**장점**

- SEO에 친화적이다.

MPA를 사용하여 여러 페이지를 생성할 수 있기 때문에 훨씬 더 많은 수의 키워드를 타겟팅할 수 있다.

**단점**

- 불필요한 로딩이 발생한다.

페이지가 바뀔 때마다 매번 완전한 페이지를 응답받기 때문에 페이지 이동 시 불필요한 로딩이 발생한다.

- 화면이 깜빡인다.

다른 페이지로 넘어가거나 새로고침 시 화면이 깜빡인다. 이것은 사용자 경험에 안좋은 영향을 미친다.

### SSG

Static Site Generator로 SSR과 같이 서버로부터 완성된 HTML을 받아오지만 HTML 파일의 생성시점이 빌드타임이라는 것이 다르다.

### 렌더링

CSR(Client-side Rendering), SSR(Server-side Rendering)에 공통적으로 **Rendering** 이 들어간다.

렌더링이란 개발자가 작성한 문서가 브라우저에 출력되는 과정을 말한다.

브라우저마다 렌더링을 수행하는 렌더링 엔진을 가지고 있다. (ex 크롬 - 블링크, 사파리 - 웹킷)

### 렌더링 과정

1. [DOM](#dom) 트리 생성

<img src="https://blog.kakaocdn.net/dn/Tznkz/btq3UsUBn0K/JZP3rvN97XgT9Qq0fPSil0/img.png" width="80%"/>

<img src="https://velog.velcdn.com/images/tnehd1998/post/0cee5616-2c9a-4012-ac13-3cbe3e85d7f9/image.png" width="80%"/>

브라우저가 **HTML의 원시 바이트**를 읽어와 HTML에 정의된 인코딩에 따라 개별 **문자**로 변환한다.

<img src="https://velog.velcdn.com/images/tnehd1998/post/ef5f08e1-f991-442c-9bcb-45df60280a81/image.png" width="80%"/>

브라우저가 **문자열**을 [W3C](#w3c) 표준에 지정된 **고유 토큰**으로 반환한다.

방출된 토큰은 해당 속성 및 규칙을 정의하는 **객체**로 변환된다.

HTML 마크업에 정의된 여러 태그 간의 관계를 해석하여 트리 구조로 연결된다.

2. CSSOM 트리 생성

동일한 방법으로 CSSOM (CSS Object Model) 트리를 생성한다.

3. Rendering Tree 생성

<img src="https://velog.velcdn.com/images/zaman17/post/c676ccc7-e216-43c4-94a6-b31f6e2d128f/image.png" width="80%"/>

DOM 트리와 CSSOM 트리가 만들어지면 둘을 결합해 렌더링 트리 (Rendering Tree)를 생성한다.

렌더링 트리에는 페이지를 렌더링 하는데 필요한 노드만 포함된다.

4. 레이아웃

렌더링 트리의 노드들에 대한 위치와 크기를 계산한다.

페이지 상에 존재하는 모든 객체의 정확한 위치와 크기를 계산한다.

5. 페인팅 or 래스터화

렌더링 트리의 각 노드를 화면의 실제 픽셀로 변환한다.

레이아웃 단계에서 계산된 각 노드들의 위치, 색상 등 스타일을 실제 픽셀로 변환하게 된다.

### 리플로우

웹 페이지의 변경이 일어나면 변경으로 영향을 받게되는 모든 노드에 대해 렌더링 트리 생성과 레이아웃 과정을 다시 수행하는 데 이를 리플로우 (Reflow) 라고 한다.

**리플로우가 일어나는 대표적인 속성**

```
position, width, height, margin, padding, border, border-width,font-size, font-weight, line-height, text-align, overflow
```

### 리페인트

리플로우를 수행한 후 그 결과를 화면에 그려지기 위해 다시 페인팅 단계를 거쳐야 하는 데 이를 리페인트 (Repaint) 라고 한다.

항상 리플로우-리페인트가 일어나는 것은 아니고 레이아웃에 영향이 미치지 않는 단순한 색상 변경 같은 변경사항은 리플로우 없이 리페인트만 수행하게 된다.

주의할 점은 리플로우가 일어나면 리페인트는 반드시 일어나게 된다.

**리플로우가 일어나는 대표적인 속성**

```
background, color, text-decoration, border-style, border-radius
```

불러와야 할 파일이 너무 많거나 무겁다면 로딩 시간이 길어지기 때문에 우리는 빠른 시간에 내용들이 나올 수 있도록 속도를 개선해야한다.

실제 렌더링 과정을 확인하기 위해서는 구글의 Light House 기능을 사용할 수 있다.

전세계의 인터넷 속도는 평균 30Mbps가 넘지 않는다.

<!-- ### 브라우저 구성 요소

브라우저는 **사용자 인터페이스, 브라우저 엔진, 렌더링 엔진, 네트워크, 자바스크립트 인터프리터, UI백엔드, 스토리지** 로 구성되어있다. -->

### DOM

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20210908120846/DOM.png" width="80%"/>

DOM이란 Document Object Model로 문서 객체 모델이다.
DOM은 웹페이지의 구조나 스타일 요소 등을 구조화 시켜 표현하여 프로그래밍 언어가 해당 문서에 접근하여 읽고 조작할 수 있도록 돕는 일종의 인터페이스다.

HTML 문서를 계층적 구조와 정보로 표현하며 트리 자료구조이기도 하다.

즉 브라우저는 이 DOM을 토대로 화면에 웹 콘텐츠들을 렌더링 한다.

자바스크립트와 같은 스크립팅 언어를 이용해 DOM 을 수정할 수 있다.

### W3C

W3C란 월드 와이드 웹을 위한 표준을 개발하고 장려하는 조직으로 회원기구, 정직원, 공공기관이 협력하여 웹 표준을 개발하는 국제 컨소시엄이다.

### 주소창에 www.google.com을 입력했을 때 일어나는 과정

1. www.google.com 을 입력하면 입력한 url 주소 중 google.com을 DNS 서버에서 검색한다.

DNS란 도메인 이름 시스템으로 사람이 읽을 수 있는 도메인 이름 (ex www.google.com)을 머신이 읽을 수 있는 IP주소로 변환하는 시스템이다.

2. 가장 가까운 DNS 서버에서 해당 도메인 이름에 해당하는 IP 주소를 찾아 사용자가 입력한 url 정보와 함께 전달한다. (IP 주소 & url 정보)

3. 전달받은 IP 주소를 이용하여 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 html 문서를 요청한다.

해당 HTTP 요청 메세지는 TCP/IP 프로토콜을 사용하여 서버로 전송된다.

4. 웹 서버는 WAS와 데이터베이스에서 웹페이지 작업을 처리한다.

웹 서버 혼자 모든 로직 처리와 데이터 관리를 하게되면 서버에 과부하가 일어날 수 있기 때문에 서버의 일을 돕는 WAS가 필요하다.

WAS란 사용자의 컴퓨터나 장치에 웹 어플리케이션을 수행해주는 미들웨어다.

특정 데이터 요청을 브라우저로부터 받게되면 웹 서버는 페이지의 로직이나 데이터베이스 연동을 위해 WAS에게 이들의 처리를 요청한다.

WAS는 요청을 받아 동적인 파일 (JS, TS)을 처리하고 DB에서 필요한 데이터 정보를 받아 그에 맞는 파일을 생성한다.

5. WAS에서의 작업 처리 결과들을 웹 서버로 전송하고 웹 서버는 웹 브라우저에게 html 문서 결과를 전달한다.

status code를 통해 서버 요청에 따른 결과 및 상태를 전달한다.

<img src="https://velog.velcdn.com/images/tnehd1998/post/c8ba71bf-8623-45ca-a3fb-50fc4c17872a/image.png" width="80%"/>

6. 위에서 작성한 웹 브라우저에 렌더링되는 과정

7. www.googlem.com 화면이 웹 브라우저에 출력된다.

**요약**

google.com 을 DNS 서버에서 검색 후 해당 도메인 이름에 해당하는 IP 주소를 찾아 사용자가 입력한 url 정보와 함께 전달한다.

전달받은 IP 주소를 이용하여 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 html 문서를 요청한다.

웹 서버는 WAS와 데이터베이스에서 웹 페이지 작업을 처리한다.

WAS에서의 작업 처리 결과들을 웹 서버로 전송하고 웹 서버는 웹 브라우저에게 html 문서 결과를 전달한다.

dom 트리 생성 cssom 트리 생성 후 둘을 결합하여 렌더링 트리를 생성한다.

레이아웃 과정으로 렌더링 트리의 노드들에 대한 위치와 크기를 계산하고 페인트 과정을 통해 실제 픽셀로 변환한다.

이렇게해서 www.googlem.com 화면이 웹 브라우저에 출력된다.

### TCP/IP 프로토콜

TCP/IP는 네트워크 프로토콜 스위트로, 온라인상의 안전하고 효율적인 데이터 전송의 필수 요건을 정의한다.

TCP는 전송 제어 프로토콜 (Transmission Control Protocol)로 한 기기에서 다른 기기로 데이터를 전송하는 것을 담당하고, IP는 인터넷 프로토콜(Internet Protocol)로 데이터의 조각을 최대한 빨리 대상 IP 주소로 보내는 역할을 표시한다.

같은 결과를 목표로 하기 때문에 한 명칭으로 알려지기도 한다.

## Critical Rendering Path

Critical Rendering Path는 브라우저가 HTML, CSS 및 JavaScript를 화면의 픽셀로 변환하기 위해 거치는 일련의 단계이다.

브라우저 렌더링 과정을 Critical Rendering Path (주요 렌더링 경로)라고 한다.

Critical Rendering Path의 각 단계가 `최대한 효율적`으로 이루어지도록 만드는 것을 보통 `최적화`라고 부른다.

## TypeScript를 사용해야 하는 이유

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJRGMw%2FbtrK8fLluqy%2FNiBibmjDMc5R7hbBmU5XL0%2Fimg.jpg" width="80%" />

1. 에러를 잡아내기 쉽다.

코드에 목적을 명시하고 목적에 맞지 않는 타입의 변수나 함수들에서 에러를 발생시켜 버그를 사전에 제거한다.

2. 정적 타입 지정이 가능하다.

정적 타입 지정은 개발자의 의도를 명확하게 코드로 기술할 수 있고 이는 코드의 가독성을 높이고 디버깅을 쉽게 해줄 수 있다.

3. 협업에 용이하다.

### JavaScript

자바스크립트는 객체 기반의 스크립트 언어다.

자바스크립트는 타입을 명시할 필요가 없는 [인터프리터 언어](#인터프리터-언어)이다.

[동적 타입 언어](#동적타입)이기 때문에 런타임 속도는 빠르지만 타입 안정성이 보장되지 않는다.

### TypeScript

타입스크립트는 2012년 마이크로소프트에서 발표한 오픈소스 프로그래밍 언어로 자바스크립트에 타입을 부여한 언어이며 자바스크립트의 상위 집합이다.

타입스크립트는 [컴파일 언어](#컴파일-언어)이다.

[정적 타입 언어](#정적타입)이기 때문에 컴파일 시 시간이 조금 걸릴더라도 안정성을 보장한다.

### 정적타입

정적타입이란 **컴파일 시** 변수의 타입이 결정되는 것을 말한다.

### 동적타입

동적타입이란 **런타임 시** 변수의 타입이 결정되는 것을 말한다.

### 컴파일타임, 런타임

컴파일타임이란 프로그램을 생성하기 위해 개발자는 먼저 소스코드를 작성하고 컴퓨터가 인식할 수 있는 기계어 코드로 변환되어 실행 가능한 프로그램이 되는 과정이다.

런타임이란 컴파일 과정을 마친 프로그램이 사용자에 의해 실행되어 지는 때 를 의미한다.

### 컴파일 언어

컴파일 언어는 컴퓨터가 해석할 수 있는 언어로 변환하는 작업을 거쳐 실행되어지는 언어이다. 코드를 한꺼번에 다른 목적 코드로 번역한 후 한 번에 실행하는 언어다.

한 번 번역한 후에는 다시 번역하지 않으므로 실행 속도가 빠르다.

종류 - C, Java, C# 등

### 인터프리터 언어

인터프리터 언어는 코드를 한 줄 한 줄 읽어가며 명령을 바로 처리하는 언어이다. 번역과 실행이 동시에 이루어진다.

번역 속도는 빠르지만 프로그램 실행 시마다 매번 번역해야 하므로 실행속도는 느리다.

종류 - JavaScript, HTML, python 등

## REST API로 받은 객체와 배열은 보통 어떤 자바스크립트 API나 로직을 이용해서 화면에 맞게 가공을 하는지?

> map, filter, reduce

### map

map 은 배열 각 요소에 대해 주어진 함수를 수행한 결과를 모아 새로운 배열을 반환하는 매소드다.

```jsx
{
  restaurants?.map((restaurant) => {
    return <span key={restaurant.id}>{restaurant.name} </span>;
  });
}
```

**forEach와 map의 차이점**

forEach는 기존의 Ararry를 변경하는 반면, map은 새로운 Ararry를 반환한다.

forEach는 배열의 각 요소마다 한 번씩 콜백 함수를 실행한다.
map은 배열내 각 요소에 대해 콜백 함수를 실행하고 결과를 모아 새로운 배열을 반환한다.

### filter

filter은 배열 각 요소에 대해 주어진 함수의 **결과값이 true**인 요소를 모아 새로운 배열로 반환하는 매소드다.

```jsx
const { slug } = params;
const allPosts = getAllPosts(["title", "tags", "date", "slug"]);
const currentPost = allPosts.filter((post) => post.slug === slug)[0];
```

### reduce

reduce는 배열의 각 요소를 순회하며 callback 함수의 **실행 값을 누적하여 하나의 결과값**을 반환한다.

## 프레임워크와 라이브러리

### 프레임워크

프레임워크는 프로그램의 뼈대로 개발자가 원하는 기능 구현에만 집중할 수 있도록 기본적으로 필요한 기능을 갖추고 있다.

프레임워크는 프로그래밍 언어가 아니다.

프레임워크는 전체적인 흐름을 쥐고 있으며 애플리케이션의 코드는 프레임워크에 의해 사용된다. 애플리케이션 코드는 프레임워크가 짜놓은 틀 안에서 수동적으로 동작하기 때문에 제어의 흐름은 프레임워크에게 있다.

**장점**

1. 코드 작성이 효율적이다.

아무것도 작성되어 있지 않은 상태에서 코드를 짜는 게 아니기 때문에 시간과 비용이 훨씬 절약되어 생산성이 올라간다.

2. 코드의 질적 향상

프레임워크는 이미 검증된 코드를 사용하기 때문에 버그 발생 가능성을 저하시키고 반복 작업에서 일어날 수 있는 실수들을 방지하게 도와준다.

3. 유지 보수가 안정적이다.

코드가 비교적 체계적으로 갖춰저 있기 때문에 유집 보수 측면에서 안정적이라 볼 수 있다.

**단점**

1. 자유롭지 못한 개발 환경

프레임워크 사용시 프레임워크에 의존하고 프레임워크의 규칙을 따라야하기 때문에 자유롭고 유연하게 개발하는 데에는 한계가 있다.

**종류**

Django, Bootstrap, Angular, Vue.js

### 라이브러리

라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 언제든지 필요한 곳에 호출하여 사용할 수 있도록 구성된 것을 의미한다.

라이브러리는 개발자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰게 된다. 즉, 개발자에게 전적으로 제어 흐름이 있으며 필요할 때마다 능동적으로 라이브러리를 호출하여 사용한다.

**장점**

1. 코드의 중복을 줄인다.

2. 개발 시간을 단축할 수 있다.

**종류**

React, Three.js

프레임워크와 라이브러리의 가장 중요한 차이점은 **제어 흐름**이다.

## 동기 (Synchronous)

동기적 처리란 어떠한 요청이 오면 **다 완료가 된 후 다음 요청을 실행하는 것**을 의미한다.

## 비동기 (Asynchronous)

비동기 처리란 어떠한 요청이 오면 해당 요청이 완료될 때까지 기다리지 않고 **다음 코드를 먼저 수행하는 것**을 의미한다.

---

# 이것 저것

## Numeric separators

[Numeric separators](https://v8.dev/features/numeric-separators)는 ES12(ES2021)에 추가된 최신 문법으로 숫자 단위를 간편하게 구분해주는 문법이다.

```js
const BIGNUMBER = 1234567890; // 엄청 큰 숫자
const SEPARATION_BIGNUMBER = 1_234_567_890; // 언더바로 구분
```

## 변수 VS 상수

변수는 값 변경이 가능한 값이다.

상수는 값이 변하지 않는 고정된 값이다.

변수를 저장할 때는 var과 let을 사용하고 변하지 않는 상수 값을 저장할 때는 const를 사용한다.

절대적인 것은 아니지만 상수를 코드에서 찾기 쉽게 하기위해 constants들은 대문자와 언더바를 이용해 네이밍한다.

## Fragments VS <></>

리액트는 하나의 컴포넌트만을 리턴할 수 있기 때문에 return 문 안에는 반드시 하나의 최상위 태그가 있어야 한다.

<></> 가 Fragments 보다 나중에 나왔기 때문에

Fragments를 쓰면 예전 리액트 지식으로 개발하는 사람처럼 보일 수도 있으니 <></>를 사용하자
